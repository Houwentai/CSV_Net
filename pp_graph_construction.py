import os, sys
from os.path import join
import h5py
import math
from math import floor
import pdb
from time import time
from tqdm import tqdm
import joblib
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from PIL import Image
from scipy.stats import percentileofscore
import nmslib
import networkx as nx
import torch
import torch.nn as nn
import torch.nn.functional as F
import torch_geometric
from torch_geometric.utils import convert
from torch_geometric.data import Data
from torch_geometric.transforms import LargestConnectedComponents



class Hnsw:
    def __init__(self, space='cosinesimil', index_params=None,
                 query_params=None, print_progress=True):
        self.space = space
        self.index_params = index_params
        self.query_params = query_params
        self.print_progress = print_progress

    def fit(self, X):
        index_params = self.index_params
        if index_params is None:
            index_params = {'M': 16, 'post': 0, 'efConstruction': 400}

        query_params = self.query_params
        if query_params is None:
            query_params = {'ef': 90}

        # this is the actual nmslib part, hopefully the syntax should
        # be pretty readable, the documentation also has a more verbiage
        # introduction: https://nmslib.github.io/nmslib/quickstart.html
        index = nmslib.init(space=self.space, method='hnsw')
        index.addDataPointBatch(X)
        index.createIndex(index_params, print_progress=self.print_progress)
        index.setQueryTimeParams(query_params)

        self.index_ = index
        self.index_params_ = index_params
        self.query_params_ = query_params
        return self

    def query(self, vector, topn):
        # the knnQuery returns indices and corresponding distance
        # we will throw the distance away for now
        indices, dist = self.index_.knnQuery(vector, k=topn)
        return indices


def pt2graph_prototype(wsi_h5, radius=9, prototypes = prototypes):
    from torch_geometric.data import Data as geomData
    from itertools import chain
    coords, features = np.array(wsi_h5['coords']), np.array(wsi_h5['features'])
    assert coords.shape[0] == features.shape[0]
    num_patches = coords.shape[0]
    
    model = Hnsw(space='l2')
    model.fit(coords)
    a = np.repeat(range(num_patches), radius-1)
    b = np.fromiter(chain(*[model.query(coords[v_idx], topn=radius)[1:] for v_idx in range(num_patches)]),dtype=int)
    edge_spatial = torch.Tensor(np.stack([a,b])).type(torch.LongTensor)
    
    if prototypes == None:
        G = geomData(phenotypes = torch.Tensor(features),
                    edge_index = edge_spatial,
                    centroid = torch.Tensor(coords))  
    else:    
        distances = np.linalg.norm(features[:, np.newaxis] - prototypes, axis=2) 
        feature_to_prototype = prototypes[np.argmin(distances, axis=1)] 


        G = geomData(phenotypes = torch.Tensor(features),
                    prototypes = torch.Tensor(feature_to_prototype),
                    edge_index = edge_spatial,
                    centroid = torch.Tensor(coords))
    return G


def createDir_h5toPyG_prototype(h5_path, save_path, prototypes = prototypes):
    pbar = tqdm(os.listdir(h5_path))
    for h5_fname in pbar:
        pbar.set_description('%s - Creating Graph' % (h5_fname[:12]))

        try:
            wsi_h5 = h5py.File(os.path.join(h5_path, h5_fname), "r")
            G = pt2graph_prototype(wsi_h5, radius=9, prototypes = prototypes)
            torch.save(G, os.path.join(save_path, h5_fname[:-3]+'.pt'))
            wsi_h5.close()
        except OSError:
            pbar.set_description('%s - Broken H5' % (h5_fname[:12]))
            print(h5_fname, 'Broken')






if __name__ == "__main__":
    ''' phenotype graph '''
    h5_path = "../h5_files"  '''.h5files generated by CLAM'''
    phenotype_graph_save_path = '../Phenotypes_GRAPH_DIRECTORY/'
    os.makedirs(pp_graph_save_path, exist_ok=True)
    createDir_h5toPyG_prototype(h5_path, phenotype_graph_save_path, prototypes = None)
    
    ''' LargestComponent phenotype graph '''
    LargestComponent_save_path = '../Phenotypes_LargestComponent_Graph_DIRECTORY/'
    transform = LargestConnectedComponents(num_components=1, connection='strong')
    os.makedirs(LargestComponent_save_path, exist_ok=True)
    for i in tqdm(os.listdir(phenotype_graph_save_path)):
        temp = torch.load(os.path.join(phenotype_graph_save_path,i))
        new_temp = transform(temp)
        torch.save(new_temp, os.path.join(LargestComponent_save_path,i))
    
    '''pp graph'''
    prototypes = joblib.load("../weights_16.pkl")[0].cpu().numpy()
    PP_LargestComponent_GRAPH_save_path = '../PP_LargestComponent_Graph_DIRECTORY/'
    os.makedirs(PP_LargestComponent_GRAPH_save_path, exist_ok=True)
    
    for i in tqdm(os.listdir(LargestComponent_save_path)):
        temp = torch.load(os.path.join(LargestComponent_save_path,i))
        coords, features = temp.centroid.numpy(), temp.phenotypes.numpy()
        distances = np.linalg.norm(features[:, np.newaxis] - prototypes, axis=2)  
        feature_to_prototype = prototypes[np.argmin(distances, axis=1)]  
        temp.prototypes = torch.Tensor(feature_to_prototype)
        torch.save(temp, os.path.join(PP_LargestComponent_GRAPH_save_path,i))
        
